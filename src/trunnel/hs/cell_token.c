/* cell_token.c -- generated by Trunnel v1.5.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#include <stdlib.h>
#include "trunnel-impl.h"

#include "cell_token.h"

#define TRUNNEL_SET_ERROR_CODE(obj) \
  do {                              \
    (obj)->trunnel_error_code_ = 1; \
  } while (0)

#if defined(__COVERITY__) || defined(__clang_analyzer__)
/* If we're running a static analysis tool, we don't want it to complain
 * that some of our remaining-bytes checks are dead-code. */
int celltoken_deadcode_dummy__ = 0;
#define OR_DEADCODE_DUMMY || celltoken_deadcode_dummy__
#else
#define OR_DEADCODE_DUMMY
#endif

#define CHECK_REMAINING(nbytes, label)                           \
  do {                                                           \
    if (remaining < (nbytes) OR_DEADCODE_DUMMY) {                \
      goto label;                                                \
    }                                                            \
  } while (0)

typedef struct trn_cell_extension_st trn_cell_extension_t;
trn_cell_extension_t *trn_cell_extension_new(void);
void trn_cell_extension_free(trn_cell_extension_t *victim);
ssize_t trn_cell_extension_parse(trn_cell_extension_t **output, const uint8_t *input, const size_t len_in);
ssize_t trn_cell_extension_encoded_len(const trn_cell_extension_t *obj);
ssize_t trn_cell_extension_encode(uint8_t *output, size_t avail, const trn_cell_extension_t *input);
const char *trn_cell_extension_check(const trn_cell_extension_t *obj);
int trn_cell_extension_clear_errors(trn_cell_extension_t *obj);
trn_dleq_pk_t *
trn_dleq_pk_new(void)
{
  trn_dleq_pk_t *val = trunnel_calloc(1, sizeof(trn_dleq_pk_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
trn_dleq_pk_clear(trn_dleq_pk_t *obj)
{
  (void) obj;
}

void
trn_dleq_pk_free(trn_dleq_pk_t *obj)
{
  if (obj == NULL)
    return;
  trn_dleq_pk_clear(obj);
  trunnel_memwipe(obj, sizeof(trn_dleq_pk_t));
  trunnel_free_(obj);
}

size_t
trn_dleq_pk_getlen_dleq_pk(const trn_dleq_pk_t *inp)
{
  (void)inp;  return TRUNNEL_HS_DLEQ_PK_LEN;
}

uint8_t
trn_dleq_pk_get_dleq_pk(trn_dleq_pk_t *inp, size_t idx)
{
  trunnel_assert(idx < TRUNNEL_HS_DLEQ_PK_LEN);
  return inp->dleq_pk[idx];
}

uint8_t
trn_dleq_pk_getconst_dleq_pk(const trn_dleq_pk_t *inp, size_t idx)
{
  return trn_dleq_pk_get_dleq_pk((trn_dleq_pk_t*)inp, idx);
}
int
trn_dleq_pk_set_dleq_pk(trn_dleq_pk_t *inp, size_t idx, uint8_t elt)
{
  trunnel_assert(idx < TRUNNEL_HS_DLEQ_PK_LEN);
  inp->dleq_pk[idx] = elt;
  return 0;
}

uint8_t *
trn_dleq_pk_getarray_dleq_pk(trn_dleq_pk_t *inp)
{
  return inp->dleq_pk;
}
const uint8_t  *
trn_dleq_pk_getconstarray_dleq_pk(const trn_dleq_pk_t *inp)
{
  return (const uint8_t  *)trn_dleq_pk_getarray_dleq_pk((trn_dleq_pk_t*)inp);
}
const char *
trn_dleq_pk_check(const trn_dleq_pk_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  return NULL;
}

ssize_t
trn_dleq_pk_encoded_len(const trn_dleq_pk_t *obj)
{
  ssize_t result = 0;

  if (NULL != trn_dleq_pk_check(obj))
     return -1;


  /* Length of u8 dleq_pk[TRUNNEL_HS_DLEQ_PK_LEN] */
  result += TRUNNEL_HS_DLEQ_PK_LEN;
  return result;
}
int
trn_dleq_pk_clear_errors(trn_dleq_pk_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
trn_dleq_pk_encode(uint8_t *output, const size_t avail, const trn_dleq_pk_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = trn_dleq_pk_encoded_len(obj);
#endif

  if (NULL != (msg = trn_dleq_pk_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 dleq_pk[TRUNNEL_HS_DLEQ_PK_LEN] */
  trunnel_assert(written <= avail);
  if (avail - written < TRUNNEL_HS_DLEQ_PK_LEN)
    goto truncated;
  memcpy(ptr, obj->dleq_pk, TRUNNEL_HS_DLEQ_PK_LEN);
  written += TRUNNEL_HS_DLEQ_PK_LEN; ptr += TRUNNEL_HS_DLEQ_PK_LEN;


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As trn_dleq_pk_parse(), but do not allocate the output object.
 */
static ssize_t
trn_dleq_pk_parse_into(trn_dleq_pk_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 dleq_pk[TRUNNEL_HS_DLEQ_PK_LEN] */
  CHECK_REMAINING(TRUNNEL_HS_DLEQ_PK_LEN, truncated);
  memcpy(obj->dleq_pk, ptr, TRUNNEL_HS_DLEQ_PK_LEN);
  remaining -= TRUNNEL_HS_DLEQ_PK_LEN; ptr += TRUNNEL_HS_DLEQ_PK_LEN;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
}

ssize_t
trn_dleq_pk_parse(trn_dleq_pk_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = trn_dleq_pk_new();
  if (NULL == *output)
    return -1;
  result = trn_dleq_pk_parse_into(*output, input, len_in);
  if (result < 0) {
    trn_dleq_pk_free(*output);
    *output = NULL;
  }
  return result;
}
trn_dleq_proof_t *
trn_dleq_proof_new(void)
{
  trn_dleq_proof_t *val = trunnel_calloc(1, sizeof(trn_dleq_proof_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
trn_dleq_proof_clear(trn_dleq_proof_t *obj)
{
  (void) obj;
}

void
trn_dleq_proof_free(trn_dleq_proof_t *obj)
{
  if (obj == NULL)
    return;
  trn_dleq_proof_clear(obj);
  trunnel_memwipe(obj, sizeof(trn_dleq_proof_t));
  trunnel_free_(obj);
}

size_t
trn_dleq_proof_getlen_dleq_proof(const trn_dleq_proof_t *inp)
{
  (void)inp;  return TRUNNEL_HS_DLEQ_PROOF_LEN;
}

uint8_t
trn_dleq_proof_get_dleq_proof(trn_dleq_proof_t *inp, size_t idx)
{
  trunnel_assert(idx < TRUNNEL_HS_DLEQ_PROOF_LEN);
  return inp->dleq_proof[idx];
}

uint8_t
trn_dleq_proof_getconst_dleq_proof(const trn_dleq_proof_t *inp, size_t idx)
{
  return trn_dleq_proof_get_dleq_proof((trn_dleq_proof_t*)inp, idx);
}
int
trn_dleq_proof_set_dleq_proof(trn_dleq_proof_t *inp, size_t idx, uint8_t elt)
{
  trunnel_assert(idx < TRUNNEL_HS_DLEQ_PROOF_LEN);
  inp->dleq_proof[idx] = elt;
  return 0;
}

uint8_t *
trn_dleq_proof_getarray_dleq_proof(trn_dleq_proof_t *inp)
{
  return inp->dleq_proof;
}
const uint8_t  *
trn_dleq_proof_getconstarray_dleq_proof(const trn_dleq_proof_t *inp)
{
  return (const uint8_t  *)trn_dleq_proof_getarray_dleq_proof((trn_dleq_proof_t*)inp);
}
const char *
trn_dleq_proof_check(const trn_dleq_proof_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  return NULL;
}

ssize_t
trn_dleq_proof_encoded_len(const trn_dleq_proof_t *obj)
{
  ssize_t result = 0;

  if (NULL != trn_dleq_proof_check(obj))
     return -1;


  /* Length of u8 dleq_proof[TRUNNEL_HS_DLEQ_PROOF_LEN] */
  result += TRUNNEL_HS_DLEQ_PROOF_LEN;
  return result;
}
int
trn_dleq_proof_clear_errors(trn_dleq_proof_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
trn_dleq_proof_encode(uint8_t *output, const size_t avail, const trn_dleq_proof_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = trn_dleq_proof_encoded_len(obj);
#endif

  if (NULL != (msg = trn_dleq_proof_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 dleq_proof[TRUNNEL_HS_DLEQ_PROOF_LEN] */
  trunnel_assert(written <= avail);
  if (avail - written < TRUNNEL_HS_DLEQ_PROOF_LEN)
    goto truncated;
  memcpy(ptr, obj->dleq_proof, TRUNNEL_HS_DLEQ_PROOF_LEN);
  written += TRUNNEL_HS_DLEQ_PROOF_LEN; ptr += TRUNNEL_HS_DLEQ_PROOF_LEN;


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As trn_dleq_proof_parse(), but do not allocate the output object.
 */
static ssize_t
trn_dleq_proof_parse_into(trn_dleq_proof_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 dleq_proof[TRUNNEL_HS_DLEQ_PROOF_LEN] */
  CHECK_REMAINING(TRUNNEL_HS_DLEQ_PROOF_LEN, truncated);
  memcpy(obj->dleq_proof, ptr, TRUNNEL_HS_DLEQ_PROOF_LEN);
  remaining -= TRUNNEL_HS_DLEQ_PROOF_LEN; ptr += TRUNNEL_HS_DLEQ_PROOF_LEN;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
}

ssize_t
trn_dleq_proof_parse(trn_dleq_proof_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = trn_dleq_proof_new();
  if (NULL == *output)
    return -1;
  result = trn_dleq_proof_parse_into(*output, input, len_in);
  if (result < 0) {
    trn_dleq_proof_free(*output);
    *output = NULL;
  }
  return result;
}
trn_hs_pow_t *
trn_hs_pow_new(void)
{
  trn_hs_pow_t *val = trunnel_calloc(1, sizeof(trn_hs_pow_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
trn_hs_pow_clear(trn_hs_pow_t *obj)
{
  (void) obj;
  TRUNNEL_DYNARRAY_WIPE(&obj->proof_of_work);
  TRUNNEL_DYNARRAY_CLEAR(&obj->proof_of_work);
}

void
trn_hs_pow_free(trn_hs_pow_t *obj)
{
  if (obj == NULL)
    return;
  trn_hs_pow_clear(obj);
  trunnel_memwipe(obj, sizeof(trn_hs_pow_t));
  trunnel_free_(obj);
}

uint8_t
trn_hs_pow_get_pow_len(const trn_hs_pow_t *inp)
{
  return inp->pow_len;
}
int
trn_hs_pow_set_pow_len(trn_hs_pow_t *inp, uint8_t val)
{
  inp->pow_len = val;
  return 0;
}
size_t
trn_hs_pow_getlen_proof_of_work(const trn_hs_pow_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->proof_of_work);
}

uint8_t
trn_hs_pow_get_proof_of_work(trn_hs_pow_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->proof_of_work, idx);
}

uint8_t
trn_hs_pow_getconst_proof_of_work(const trn_hs_pow_t *inp, size_t idx)
{
  return trn_hs_pow_get_proof_of_work((trn_hs_pow_t*)inp, idx);
}
int
trn_hs_pow_set_proof_of_work(trn_hs_pow_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->proof_of_work, idx, elt);
  return 0;
}
int
trn_hs_pow_add_proof_of_work(trn_hs_pow_t *inp, uint8_t elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->proof_of_work.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->proof_of_work, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
trn_hs_pow_getarray_proof_of_work(trn_hs_pow_t *inp)
{
  return inp->proof_of_work.elts_;
}
const uint8_t  *
trn_hs_pow_getconstarray_proof_of_work(const trn_hs_pow_t *inp)
{
  return (const uint8_t  *)trn_hs_pow_getarray_proof_of_work((trn_hs_pow_t*)inp);
}
int
trn_hs_pow_setlen_proof_of_work(trn_hs_pow_t *inp, size_t newlen)
{
  uint8_t *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->proof_of_work.allocated_,
                 &inp->proof_of_work.n_, inp->proof_of_work.elts_, newlen,
                 sizeof(inp->proof_of_work.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->proof_of_work.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const char *
trn_hs_pow_check(const trn_hs_pow_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (TRUNNEL_DYNARRAY_LEN(&obj->proof_of_work) != obj->pow_len)
    return "Length mismatch for proof_of_work";
  return NULL;
}

ssize_t
trn_hs_pow_encoded_len(const trn_hs_pow_t *obj)
{
  ssize_t result = 0;

  if (NULL != trn_hs_pow_check(obj))
     return -1;


  /* Length of u8 pow_len */
  result += 1;

  /* Length of u8 proof_of_work[pow_len] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->proof_of_work);
  return result;
}
int
trn_hs_pow_clear_errors(trn_hs_pow_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
trn_hs_pow_encode(uint8_t *output, const size_t avail, const trn_hs_pow_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = trn_hs_pow_encoded_len(obj);
#endif

  if (NULL != (msg = trn_hs_pow_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 pow_len */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->pow_len));
  written += 1; ptr += 1;

  /* Encode u8 proof_of_work[pow_len] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->proof_of_work);
    trunnel_assert(obj->pow_len == elt_len);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->proof_of_work.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As trn_hs_pow_parse(), but do not allocate the output object.
 */
static ssize_t
trn_hs_pow_parse_into(trn_hs_pow_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 pow_len */
  CHECK_REMAINING(1, truncated);
  obj->pow_len = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u8 proof_of_work[pow_len] */
  CHECK_REMAINING(obj->pow_len, truncated);
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->proof_of_work, obj->pow_len, {});
  obj->proof_of_work.n_ = obj->pow_len;
  if (obj->pow_len)
    memcpy(obj->proof_of_work.elts_, ptr, obj->pow_len);
  ptr += obj->pow_len; remaining -= obj->pow_len;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 trunnel_alloc_failed:
  return -1;
}

ssize_t
trn_hs_pow_parse(trn_hs_pow_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = trn_hs_pow_new();
  if (NULL == *output)
    return -1;
  result = trn_hs_pow_parse_into(*output, input, len_in);
  if (result < 0) {
    trn_hs_pow_free(*output);
    *output = NULL;
  }
  return result;
}
trn_hs_token_t *
trn_hs_token_new(void)
{
  trn_hs_token_t *val = trunnel_calloc(1, sizeof(trn_hs_token_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
trn_hs_token_clear(trn_hs_token_t *obj)
{
  (void) obj;
}

void
trn_hs_token_free(trn_hs_token_t *obj)
{
  if (obj == NULL)
    return;
  trn_hs_token_clear(obj);
  trunnel_memwipe(obj, sizeof(trn_hs_token_t));
  trunnel_free_(obj);
}

uint8_t
trn_hs_token_get_seq_num(const trn_hs_token_t *inp)
{
  return inp->seq_num;
}
int
trn_hs_token_set_seq_num(trn_hs_token_t *inp, uint8_t val)
{
  inp->seq_num = val;
  return 0;
}
size_t
trn_hs_token_getlen_token(const trn_hs_token_t *inp)
{
  (void)inp;  return TRUNNEL_HS_TOKEN_LEN;
}

uint8_t
trn_hs_token_get_token(trn_hs_token_t *inp, size_t idx)
{
  trunnel_assert(idx < TRUNNEL_HS_TOKEN_LEN);
  return inp->token[idx];
}

uint8_t
trn_hs_token_getconst_token(const trn_hs_token_t *inp, size_t idx)
{
  return trn_hs_token_get_token((trn_hs_token_t*)inp, idx);
}
int
trn_hs_token_set_token(trn_hs_token_t *inp, size_t idx, uint8_t elt)
{
  trunnel_assert(idx < TRUNNEL_HS_TOKEN_LEN);
  inp->token[idx] = elt;
  return 0;
}

uint8_t *
trn_hs_token_getarray_token(trn_hs_token_t *inp)
{
  return inp->token;
}
const uint8_t  *
trn_hs_token_getconstarray_token(const trn_hs_token_t *inp)
{
  return (const uint8_t  *)trn_hs_token_getarray_token((trn_hs_token_t*)inp);
}
const char *
trn_hs_token_check(const trn_hs_token_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  return NULL;
}

ssize_t
trn_hs_token_encoded_len(const trn_hs_token_t *obj)
{
  ssize_t result = 0;

  if (NULL != trn_hs_token_check(obj))
     return -1;


  /* Length of u8 seq_num */
  result += 1;

  /* Length of u8 token[TRUNNEL_HS_TOKEN_LEN] */
  result += TRUNNEL_HS_TOKEN_LEN;
  return result;
}
int
trn_hs_token_clear_errors(trn_hs_token_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
trn_hs_token_encode(uint8_t *output, const size_t avail, const trn_hs_token_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = trn_hs_token_encoded_len(obj);
#endif

  if (NULL != (msg = trn_hs_token_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 seq_num */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->seq_num));
  written += 1; ptr += 1;

  /* Encode u8 token[TRUNNEL_HS_TOKEN_LEN] */
  trunnel_assert(written <= avail);
  if (avail - written < TRUNNEL_HS_TOKEN_LEN)
    goto truncated;
  memcpy(ptr, obj->token, TRUNNEL_HS_TOKEN_LEN);
  written += TRUNNEL_HS_TOKEN_LEN; ptr += TRUNNEL_HS_TOKEN_LEN;


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As trn_hs_token_parse(), but do not allocate the output object.
 */
static ssize_t
trn_hs_token_parse_into(trn_hs_token_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 seq_num */
  CHECK_REMAINING(1, truncated);
  obj->seq_num = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u8 token[TRUNNEL_HS_TOKEN_LEN] */
  CHECK_REMAINING(TRUNNEL_HS_TOKEN_LEN, truncated);
  memcpy(obj->token, ptr, TRUNNEL_HS_TOKEN_LEN);
  remaining -= TRUNNEL_HS_TOKEN_LEN; ptr += TRUNNEL_HS_TOKEN_LEN;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
}

ssize_t
trn_hs_token_parse(trn_hs_token_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = trn_hs_token_new();
  if (NULL == *output)
    return -1;
  result = trn_hs_token_parse_into(*output, input, len_in);
  if (result < 0) {
    trn_hs_token_free(*output);
    *output = NULL;
  }
  return result;
}
trn_cell_token1_t *
trn_cell_token1_new(void)
{
  trn_cell_token1_t *val = trunnel_calloc(1, sizeof(trn_cell_token1_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
trn_cell_token1_clear(trn_cell_token1_t *obj)
{
  (void) obj;
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->pow); ++idx) {
      trn_hs_pow_free(TRUNNEL_DYNARRAY_GET(&obj->pow, idx));
    }
  }
  TRUNNEL_DYNARRAY_WIPE(&obj->pow);
  TRUNNEL_DYNARRAY_CLEAR(&obj->pow);
  TRUNNEL_DYNARRAY_WIPE(&obj->batch_size);
  TRUNNEL_DYNARRAY_CLEAR(&obj->batch_size);
  trn_cell_extension_free(obj->extensions);
  obj->extensions = NULL;
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->tokens); ++idx) {
      trn_hs_token_free(TRUNNEL_DYNARRAY_GET(&obj->tokens, idx));
    }
  }
  TRUNNEL_DYNARRAY_WIPE(&obj->tokens);
  TRUNNEL_DYNARRAY_CLEAR(&obj->tokens);
}

void
trn_cell_token1_free(trn_cell_token1_t *obj)
{
  if (obj == NULL)
    return;
  trn_cell_token1_clear(obj);
  trunnel_memwipe(obj, sizeof(trn_cell_token1_t));
  trunnel_free_(obj);
}

uint8_t
trn_cell_token1_get_first_cell(const trn_cell_token1_t *inp)
{
  return inp->first_cell;
}
int
trn_cell_token1_set_first_cell(trn_cell_token1_t *inp, uint8_t val)
{
  inp->first_cell = val;
  return 0;
}
uint8_t
trn_cell_token1_get_last_cell(const trn_cell_token1_t *inp)
{
  return inp->last_cell;
}
int
trn_cell_token1_set_last_cell(trn_cell_token1_t *inp, uint8_t val)
{
  inp->last_cell = val;
  return 0;
}
size_t
trn_cell_token1_getlen_pow(const trn_cell_token1_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->pow);
}

struct trn_hs_pow_st *
trn_cell_token1_get_pow(trn_cell_token1_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->pow, idx);
}

 const struct trn_hs_pow_st *
trn_cell_token1_getconst_pow(const trn_cell_token1_t *inp, size_t idx)
{
  return trn_cell_token1_get_pow((trn_cell_token1_t*)inp, idx);
}
int
trn_cell_token1_set_pow(trn_cell_token1_t *inp, size_t idx, struct trn_hs_pow_st * elt)
{
  trn_hs_pow_t *oldval = TRUNNEL_DYNARRAY_GET(&inp->pow, idx);
  if (oldval && oldval != elt)
    trn_hs_pow_free(oldval);
  return trn_cell_token1_set0_pow(inp, idx, elt);
}
int
trn_cell_token1_set0_pow(trn_cell_token1_t *inp, size_t idx, struct trn_hs_pow_st * elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->pow, idx, elt);
  return 0;
}
int
trn_cell_token1_add_pow(trn_cell_token1_t *inp, struct trn_hs_pow_st * elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->pow.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(struct trn_hs_pow_st *, &inp->pow, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

struct trn_hs_pow_st * *
trn_cell_token1_getarray_pow(trn_cell_token1_t *inp)
{
  return inp->pow.elts_;
}
const struct trn_hs_pow_st *  const  *
trn_cell_token1_getconstarray_pow(const trn_cell_token1_t *inp)
{
  return (const struct trn_hs_pow_st *  const  *)trn_cell_token1_getarray_pow((trn_cell_token1_t*)inp);
}
int
trn_cell_token1_setlen_pow(trn_cell_token1_t *inp, size_t newlen)
{
  struct trn_hs_pow_st * *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->pow.allocated_,
                 &inp->pow.n_, inp->pow.elts_, newlen,
                 sizeof(inp->pow.elts_[0]), (trunnel_free_fn_t) trn_hs_pow_free,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->pow.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
size_t
trn_cell_token1_getlen_batch_size(const trn_cell_token1_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->batch_size);
}

uint8_t
trn_cell_token1_get_batch_size(trn_cell_token1_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->batch_size, idx);
}

uint8_t
trn_cell_token1_getconst_batch_size(const trn_cell_token1_t *inp, size_t idx)
{
  return trn_cell_token1_get_batch_size((trn_cell_token1_t*)inp, idx);
}
int
trn_cell_token1_set_batch_size(trn_cell_token1_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->batch_size, idx, elt);
  return 0;
}
int
trn_cell_token1_add_batch_size(trn_cell_token1_t *inp, uint8_t elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->batch_size.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->batch_size, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
trn_cell_token1_getarray_batch_size(trn_cell_token1_t *inp)
{
  return inp->batch_size.elts_;
}
const uint8_t  *
trn_cell_token1_getconstarray_batch_size(const trn_cell_token1_t *inp)
{
  return (const uint8_t  *)trn_cell_token1_getarray_batch_size((trn_cell_token1_t*)inp);
}
int
trn_cell_token1_setlen_batch_size(trn_cell_token1_t *inp, size_t newlen)
{
  uint8_t *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->batch_size.allocated_,
                 &inp->batch_size.n_, inp->batch_size.elts_, newlen,
                 sizeof(inp->batch_size.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->batch_size.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
struct trn_cell_extension_st *
trn_cell_token1_get_extensions(trn_cell_token1_t *inp)
{
  return inp->extensions;
}
const struct trn_cell_extension_st *
trn_cell_token1_getconst_extensions(const trn_cell_token1_t *inp)
{
  return trn_cell_token1_get_extensions((trn_cell_token1_t*) inp);
}
int
trn_cell_token1_set_extensions(trn_cell_token1_t *inp, struct trn_cell_extension_st *val)
{
  if (inp->extensions && inp->extensions != val)
    trn_cell_extension_free(inp->extensions);
  return trn_cell_token1_set0_extensions(inp, val);
}
int
trn_cell_token1_set0_extensions(trn_cell_token1_t *inp, struct trn_cell_extension_st *val)
{
  inp->extensions = val;
  return 0;
}
uint8_t
trn_cell_token1_get_token_num(const trn_cell_token1_t *inp)
{
  return inp->token_num;
}
int
trn_cell_token1_set_token_num(trn_cell_token1_t *inp, uint8_t val)
{
  inp->token_num = val;
  return 0;
}
size_t
trn_cell_token1_getlen_tokens(const trn_cell_token1_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->tokens);
}

struct trn_hs_token_st *
trn_cell_token1_get_tokens(trn_cell_token1_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->tokens, idx);
}

 const struct trn_hs_token_st *
trn_cell_token1_getconst_tokens(const trn_cell_token1_t *inp, size_t idx)
{
  return trn_cell_token1_get_tokens((trn_cell_token1_t*)inp, idx);
}
int
trn_cell_token1_set_tokens(trn_cell_token1_t *inp, size_t idx, struct trn_hs_token_st * elt)
{
  trn_hs_token_t *oldval = TRUNNEL_DYNARRAY_GET(&inp->tokens, idx);
  if (oldval && oldval != elt)
    trn_hs_token_free(oldval);
  return trn_cell_token1_set0_tokens(inp, idx, elt);
}
int
trn_cell_token1_set0_tokens(trn_cell_token1_t *inp, size_t idx, struct trn_hs_token_st * elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->tokens, idx, elt);
  return 0;
}
int
trn_cell_token1_add_tokens(trn_cell_token1_t *inp, struct trn_hs_token_st * elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->tokens.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(struct trn_hs_token_st *, &inp->tokens, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

struct trn_hs_token_st * *
trn_cell_token1_getarray_tokens(trn_cell_token1_t *inp)
{
  return inp->tokens.elts_;
}
const struct trn_hs_token_st *  const  *
trn_cell_token1_getconstarray_tokens(const trn_cell_token1_t *inp)
{
  return (const struct trn_hs_token_st *  const  *)trn_cell_token1_getarray_tokens((trn_cell_token1_t*)inp);
}
int
trn_cell_token1_setlen_tokens(trn_cell_token1_t *inp, size_t newlen)
{
  struct trn_hs_token_st * *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->tokens.allocated_,
                 &inp->tokens.n_, inp->tokens.elts_, newlen,
                 sizeof(inp->tokens.elts_[0]), (trunnel_free_fn_t) trn_hs_token_free,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->tokens.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const char *
trn_cell_token1_check(const trn_cell_token1_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  {
    const char *msg;

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->pow); ++idx) {
      if (NULL != (msg = trn_hs_pow_check(TRUNNEL_DYNARRAY_GET(&obj->pow, idx))))
        return msg;
    }
  }
  if (TRUNNEL_DYNARRAY_LEN(&obj->pow) != obj->first_cell)
    return "Length mismatch for pow";
  if (TRUNNEL_DYNARRAY_LEN(&obj->batch_size) != obj->first_cell)
    return "Length mismatch for batch_size";
  {
    const char *msg;
    if (NULL != (msg = trn_cell_extension_check(obj->extensions)))
      return msg;
  }
  {
    const char *msg;

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->tokens); ++idx) {
      if (NULL != (msg = trn_hs_token_check(TRUNNEL_DYNARRAY_GET(&obj->tokens, idx))))
        return msg;
    }
  }
  if (TRUNNEL_DYNARRAY_LEN(&obj->tokens) != obj->token_num)
    return "Length mismatch for tokens";
  return NULL;
}

ssize_t
trn_cell_token1_encoded_len(const trn_cell_token1_t *obj)
{
  ssize_t result = 0;

  if (NULL != trn_cell_token1_check(obj))
     return -1;


  /* Length of u8 first_cell */
  result += 1;

  /* Length of u8 last_cell */
  result += 1;

  /* Length of struct trn_hs_pow pow[first_cell] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->pow); ++idx) {
      result += trn_hs_pow_encoded_len(TRUNNEL_DYNARRAY_GET(&obj->pow, idx));
    }
  }

  /* Length of u8 batch_size[first_cell] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->batch_size);

  /* Length of struct trn_cell_extension extensions */
  result += trn_cell_extension_encoded_len(obj->extensions);

  /* Length of u8 token_num */
  result += 1;

  /* Length of struct trn_hs_token tokens[token_num] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->tokens); ++idx) {
      result += trn_hs_token_encoded_len(TRUNNEL_DYNARRAY_GET(&obj->tokens, idx));
    }
  }
  return result;
}
int
trn_cell_token1_clear_errors(trn_cell_token1_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
trn_cell_token1_encode(uint8_t *output, const size_t avail, const trn_cell_token1_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = trn_cell_token1_encoded_len(obj);
#endif

  if (NULL != (msg = trn_cell_token1_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 first_cell */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->first_cell));
  written += 1; ptr += 1;

  /* Encode u8 last_cell */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->last_cell));
  written += 1; ptr += 1;

  /* Encode struct trn_hs_pow pow[first_cell] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->pow); ++idx) {
      trunnel_assert(written <= avail);
      result = trn_hs_pow_encode(ptr, avail - written, TRUNNEL_DYNARRAY_GET(&obj->pow, idx));
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
    }
  }

  /* Encode u8 batch_size[first_cell] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->batch_size);
    trunnel_assert(obj->first_cell == elt_len);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->batch_size.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }

  /* Encode struct trn_cell_extension extensions */
  trunnel_assert(written <= avail);
  result = trn_cell_extension_encode(ptr, avail - written, obj->extensions);
  if (result < 0)
    goto fail; /* XXXXXXX !*/
  written += result; ptr += result;

  /* Encode u8 token_num */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->token_num));
  written += 1; ptr += 1;

  /* Encode struct trn_hs_token tokens[token_num] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->tokens); ++idx) {
      trunnel_assert(written <= avail);
      result = trn_hs_token_encode(ptr, avail - written, TRUNNEL_DYNARRAY_GET(&obj->tokens, idx));
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
    }
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As trn_cell_token1_parse(), but do not allocate the output object.
 */
static ssize_t
trn_cell_token1_parse_into(trn_cell_token1_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 first_cell */
  CHECK_REMAINING(1, truncated);
  obj->first_cell = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u8 last_cell */
  CHECK_REMAINING(1, truncated);
  obj->last_cell = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse struct trn_hs_pow pow[first_cell] */
  TRUNNEL_DYNARRAY_EXPAND(trn_hs_pow_t *, &obj->pow, obj->first_cell, {});
  {
    trn_hs_pow_t * elt;
    unsigned idx;
    for (idx = 0; idx < obj->first_cell; ++idx) {
      result = trn_hs_pow_parse(&elt, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      TRUNNEL_DYNARRAY_ADD(trn_hs_pow_t *, &obj->pow, elt, {trn_hs_pow_free(elt);});
    }
  }

  /* Parse u8 batch_size[first_cell] */
  CHECK_REMAINING(obj->first_cell, truncated);
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->batch_size, obj->first_cell, {});
  obj->batch_size.n_ = obj->first_cell;
  if (obj->first_cell)
    memcpy(obj->batch_size.elts_, ptr, obj->first_cell);
  ptr += obj->first_cell; remaining -= obj->first_cell;

  /* Parse struct trn_cell_extension extensions */
  result = trn_cell_extension_parse(&obj->extensions, ptr, remaining);
  if (result < 0)
    goto relay_fail;
  trunnel_assert((size_t)result <= remaining);
  remaining -= result; ptr += result;

  /* Parse u8 token_num */
  CHECK_REMAINING(1, truncated);
  obj->token_num = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse struct trn_hs_token tokens[token_num] */
  TRUNNEL_DYNARRAY_EXPAND(trn_hs_token_t *, &obj->tokens, obj->token_num, {});
  {
    trn_hs_token_t * elt;
    unsigned idx;
    for (idx = 0; idx < obj->token_num; ++idx) {
      result = trn_hs_token_parse(&elt, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      TRUNNEL_DYNARRAY_ADD(trn_hs_token_t *, &obj->tokens, elt, {trn_hs_token_free(elt);});
    }
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 relay_fail:
  trunnel_assert(result < 0);
  return result;
 trunnel_alloc_failed:
  return -1;
}

ssize_t
trn_cell_token1_parse(trn_cell_token1_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = trn_cell_token1_new();
  if (NULL == *output)
    return -1;
  result = trn_cell_token1_parse_into(*output, input, len_in);
  if (result < 0) {
    trn_cell_token1_free(*output);
    *output = NULL;
  }
  return result;
}
trn_cell_token2_t *
trn_cell_token2_new(void)
{
  trn_cell_token2_t *val = trunnel_calloc(1, sizeof(trn_cell_token2_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
trn_cell_token2_clear(trn_cell_token2_t *obj)
{
  (void) obj;
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->dleq_pk); ++idx) {
      trn_dleq_pk_free(TRUNNEL_DYNARRAY_GET(&obj->dleq_pk, idx));
    }
  }
  TRUNNEL_DYNARRAY_WIPE(&obj->dleq_pk);
  TRUNNEL_DYNARRAY_CLEAR(&obj->dleq_pk);
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->dleq_proof); ++idx) {
      trn_dleq_proof_free(TRUNNEL_DYNARRAY_GET(&obj->dleq_proof, idx));
    }
  }
  TRUNNEL_DYNARRAY_WIPE(&obj->dleq_proof);
  TRUNNEL_DYNARRAY_CLEAR(&obj->dleq_proof);
  TRUNNEL_DYNARRAY_WIPE(&obj->batch_size);
  TRUNNEL_DYNARRAY_CLEAR(&obj->batch_size);
  trn_cell_extension_free(obj->extensions);
  obj->extensions = NULL;
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->tokens); ++idx) {
      trn_hs_token_free(TRUNNEL_DYNARRAY_GET(&obj->tokens, idx));
    }
  }
  TRUNNEL_DYNARRAY_WIPE(&obj->tokens);
  TRUNNEL_DYNARRAY_CLEAR(&obj->tokens);
}

void
trn_cell_token2_free(trn_cell_token2_t *obj)
{
  if (obj == NULL)
    return;
  trn_cell_token2_clear(obj);
  trunnel_memwipe(obj, sizeof(trn_cell_token2_t));
  trunnel_free_(obj);
}

uint8_t
trn_cell_token2_get_first_cell(const trn_cell_token2_t *inp)
{
  return inp->first_cell;
}
int
trn_cell_token2_set_first_cell(trn_cell_token2_t *inp, uint8_t val)
{
  inp->first_cell = val;
  return 0;
}
uint8_t
trn_cell_token2_get_last_cell(const trn_cell_token2_t *inp)
{
  return inp->last_cell;
}
int
trn_cell_token2_set_last_cell(trn_cell_token2_t *inp, uint8_t val)
{
  inp->last_cell = val;
  return 0;
}
size_t
trn_cell_token2_getlen_dleq_pk(const trn_cell_token2_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->dleq_pk);
}

struct trn_dleq_pk_st *
trn_cell_token2_get_dleq_pk(trn_cell_token2_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->dleq_pk, idx);
}

 const struct trn_dleq_pk_st *
trn_cell_token2_getconst_dleq_pk(const trn_cell_token2_t *inp, size_t idx)
{
  return trn_cell_token2_get_dleq_pk((trn_cell_token2_t*)inp, idx);
}
int
trn_cell_token2_set_dleq_pk(trn_cell_token2_t *inp, size_t idx, struct trn_dleq_pk_st * elt)
{
  trn_dleq_pk_t *oldval = TRUNNEL_DYNARRAY_GET(&inp->dleq_pk, idx);
  if (oldval && oldval != elt)
    trn_dleq_pk_free(oldval);
  return trn_cell_token2_set0_dleq_pk(inp, idx, elt);
}
int
trn_cell_token2_set0_dleq_pk(trn_cell_token2_t *inp, size_t idx, struct trn_dleq_pk_st * elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->dleq_pk, idx, elt);
  return 0;
}
int
trn_cell_token2_add_dleq_pk(trn_cell_token2_t *inp, struct trn_dleq_pk_st * elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->dleq_pk.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(struct trn_dleq_pk_st *, &inp->dleq_pk, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

struct trn_dleq_pk_st * *
trn_cell_token2_getarray_dleq_pk(trn_cell_token2_t *inp)
{
  return inp->dleq_pk.elts_;
}
const struct trn_dleq_pk_st *  const  *
trn_cell_token2_getconstarray_dleq_pk(const trn_cell_token2_t *inp)
{
  return (const struct trn_dleq_pk_st *  const  *)trn_cell_token2_getarray_dleq_pk((trn_cell_token2_t*)inp);
}
int
trn_cell_token2_setlen_dleq_pk(trn_cell_token2_t *inp, size_t newlen)
{
  struct trn_dleq_pk_st * *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->dleq_pk.allocated_,
                 &inp->dleq_pk.n_, inp->dleq_pk.elts_, newlen,
                 sizeof(inp->dleq_pk.elts_[0]), (trunnel_free_fn_t) trn_dleq_pk_free,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->dleq_pk.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
size_t
trn_cell_token2_getlen_dleq_proof(const trn_cell_token2_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->dleq_proof);
}

struct trn_dleq_proof_st *
trn_cell_token2_get_dleq_proof(trn_cell_token2_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->dleq_proof, idx);
}

 const struct trn_dleq_proof_st *
trn_cell_token2_getconst_dleq_proof(const trn_cell_token2_t *inp, size_t idx)
{
  return trn_cell_token2_get_dleq_proof((trn_cell_token2_t*)inp, idx);
}
int
trn_cell_token2_set_dleq_proof(trn_cell_token2_t *inp, size_t idx, struct trn_dleq_proof_st * elt)
{
  trn_dleq_proof_t *oldval = TRUNNEL_DYNARRAY_GET(&inp->dleq_proof, idx);
  if (oldval && oldval != elt)
    trn_dleq_proof_free(oldval);
  return trn_cell_token2_set0_dleq_proof(inp, idx, elt);
}
int
trn_cell_token2_set0_dleq_proof(trn_cell_token2_t *inp, size_t idx, struct trn_dleq_proof_st * elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->dleq_proof, idx, elt);
  return 0;
}
int
trn_cell_token2_add_dleq_proof(trn_cell_token2_t *inp, struct trn_dleq_proof_st * elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->dleq_proof.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(struct trn_dleq_proof_st *, &inp->dleq_proof, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

struct trn_dleq_proof_st * *
trn_cell_token2_getarray_dleq_proof(trn_cell_token2_t *inp)
{
  return inp->dleq_proof.elts_;
}
const struct trn_dleq_proof_st *  const  *
trn_cell_token2_getconstarray_dleq_proof(const trn_cell_token2_t *inp)
{
  return (const struct trn_dleq_proof_st *  const  *)trn_cell_token2_getarray_dleq_proof((trn_cell_token2_t*)inp);
}
int
trn_cell_token2_setlen_dleq_proof(trn_cell_token2_t *inp, size_t newlen)
{
  struct trn_dleq_proof_st * *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->dleq_proof.allocated_,
                 &inp->dleq_proof.n_, inp->dleq_proof.elts_, newlen,
                 sizeof(inp->dleq_proof.elts_[0]), (trunnel_free_fn_t) trn_dleq_proof_free,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->dleq_proof.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
size_t
trn_cell_token2_getlen_batch_size(const trn_cell_token2_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->batch_size);
}

uint8_t
trn_cell_token2_get_batch_size(trn_cell_token2_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->batch_size, idx);
}

uint8_t
trn_cell_token2_getconst_batch_size(const trn_cell_token2_t *inp, size_t idx)
{
  return trn_cell_token2_get_batch_size((trn_cell_token2_t*)inp, idx);
}
int
trn_cell_token2_set_batch_size(trn_cell_token2_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->batch_size, idx, elt);
  return 0;
}
int
trn_cell_token2_add_batch_size(trn_cell_token2_t *inp, uint8_t elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->batch_size.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->batch_size, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
trn_cell_token2_getarray_batch_size(trn_cell_token2_t *inp)
{
  return inp->batch_size.elts_;
}
const uint8_t  *
trn_cell_token2_getconstarray_batch_size(const trn_cell_token2_t *inp)
{
  return (const uint8_t  *)trn_cell_token2_getarray_batch_size((trn_cell_token2_t*)inp);
}
int
trn_cell_token2_setlen_batch_size(trn_cell_token2_t *inp, size_t newlen)
{
  uint8_t *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->batch_size.allocated_,
                 &inp->batch_size.n_, inp->batch_size.elts_, newlen,
                 sizeof(inp->batch_size.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->batch_size.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
struct trn_cell_extension_st *
trn_cell_token2_get_extensions(trn_cell_token2_t *inp)
{
  return inp->extensions;
}
const struct trn_cell_extension_st *
trn_cell_token2_getconst_extensions(const trn_cell_token2_t *inp)
{
  return trn_cell_token2_get_extensions((trn_cell_token2_t*) inp);
}
int
trn_cell_token2_set_extensions(trn_cell_token2_t *inp, struct trn_cell_extension_st *val)
{
  if (inp->extensions && inp->extensions != val)
    trn_cell_extension_free(inp->extensions);
  return trn_cell_token2_set0_extensions(inp, val);
}
int
trn_cell_token2_set0_extensions(trn_cell_token2_t *inp, struct trn_cell_extension_st *val)
{
  inp->extensions = val;
  return 0;
}
uint8_t
trn_cell_token2_get_token_num(const trn_cell_token2_t *inp)
{
  return inp->token_num;
}
int
trn_cell_token2_set_token_num(trn_cell_token2_t *inp, uint8_t val)
{
  inp->token_num = val;
  return 0;
}
size_t
trn_cell_token2_getlen_tokens(const trn_cell_token2_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->tokens);
}

struct trn_hs_token_st *
trn_cell_token2_get_tokens(trn_cell_token2_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->tokens, idx);
}

 const struct trn_hs_token_st *
trn_cell_token2_getconst_tokens(const trn_cell_token2_t *inp, size_t idx)
{
  return trn_cell_token2_get_tokens((trn_cell_token2_t*)inp, idx);
}
int
trn_cell_token2_set_tokens(trn_cell_token2_t *inp, size_t idx, struct trn_hs_token_st * elt)
{
  trn_hs_token_t *oldval = TRUNNEL_DYNARRAY_GET(&inp->tokens, idx);
  if (oldval && oldval != elt)
    trn_hs_token_free(oldval);
  return trn_cell_token2_set0_tokens(inp, idx, elt);
}
int
trn_cell_token2_set0_tokens(trn_cell_token2_t *inp, size_t idx, struct trn_hs_token_st * elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->tokens, idx, elt);
  return 0;
}
int
trn_cell_token2_add_tokens(trn_cell_token2_t *inp, struct trn_hs_token_st * elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->tokens.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(struct trn_hs_token_st *, &inp->tokens, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

struct trn_hs_token_st * *
trn_cell_token2_getarray_tokens(trn_cell_token2_t *inp)
{
  return inp->tokens.elts_;
}
const struct trn_hs_token_st *  const  *
trn_cell_token2_getconstarray_tokens(const trn_cell_token2_t *inp)
{
  return (const struct trn_hs_token_st *  const  *)trn_cell_token2_getarray_tokens((trn_cell_token2_t*)inp);
}
int
trn_cell_token2_setlen_tokens(trn_cell_token2_t *inp, size_t newlen)
{
  struct trn_hs_token_st * *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->tokens.allocated_,
                 &inp->tokens.n_, inp->tokens.elts_, newlen,
                 sizeof(inp->tokens.elts_[0]), (trunnel_free_fn_t) trn_hs_token_free,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->tokens.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const char *
trn_cell_token2_check(const trn_cell_token2_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  {
    const char *msg;

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->dleq_pk); ++idx) {
      if (NULL != (msg = trn_dleq_pk_check(TRUNNEL_DYNARRAY_GET(&obj->dleq_pk, idx))))
        return msg;
    }
  }
  if (TRUNNEL_DYNARRAY_LEN(&obj->dleq_pk) != obj->first_cell)
    return "Length mismatch for dleq_pk";
  {
    const char *msg;

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->dleq_proof); ++idx) {
      if (NULL != (msg = trn_dleq_proof_check(TRUNNEL_DYNARRAY_GET(&obj->dleq_proof, idx))))
        return msg;
    }
  }
  if (TRUNNEL_DYNARRAY_LEN(&obj->dleq_proof) != obj->first_cell)
    return "Length mismatch for dleq_proof";
  if (TRUNNEL_DYNARRAY_LEN(&obj->batch_size) != obj->first_cell)
    return "Length mismatch for batch_size";
  {
    const char *msg;
    if (NULL != (msg = trn_cell_extension_check(obj->extensions)))
      return msg;
  }
  {
    const char *msg;

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->tokens); ++idx) {
      if (NULL != (msg = trn_hs_token_check(TRUNNEL_DYNARRAY_GET(&obj->tokens, idx))))
        return msg;
    }
  }
  if (TRUNNEL_DYNARRAY_LEN(&obj->tokens) != obj->token_num)
    return "Length mismatch for tokens";
  return NULL;
}

ssize_t
trn_cell_token2_encoded_len(const trn_cell_token2_t *obj)
{
  ssize_t result = 0;

  if (NULL != trn_cell_token2_check(obj))
     return -1;


  /* Length of u8 first_cell */
  result += 1;

  /* Length of u8 last_cell */
  result += 1;

  /* Length of struct trn_dleq_pk dleq_pk[first_cell] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->dleq_pk); ++idx) {
      result += trn_dleq_pk_encoded_len(TRUNNEL_DYNARRAY_GET(&obj->dleq_pk, idx));
    }
  }

  /* Length of struct trn_dleq_proof dleq_proof[first_cell] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->dleq_proof); ++idx) {
      result += trn_dleq_proof_encoded_len(TRUNNEL_DYNARRAY_GET(&obj->dleq_proof, idx));
    }
  }

  /* Length of u8 batch_size[first_cell] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->batch_size);

  /* Length of struct trn_cell_extension extensions */
  result += trn_cell_extension_encoded_len(obj->extensions);

  /* Length of u8 token_num */
  result += 1;

  /* Length of struct trn_hs_token tokens[token_num] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->tokens); ++idx) {
      result += trn_hs_token_encoded_len(TRUNNEL_DYNARRAY_GET(&obj->tokens, idx));
    }
  }
  return result;
}
int
trn_cell_token2_clear_errors(trn_cell_token2_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
trn_cell_token2_encode(uint8_t *output, const size_t avail, const trn_cell_token2_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = trn_cell_token2_encoded_len(obj);
#endif

  if (NULL != (msg = trn_cell_token2_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 first_cell */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->first_cell));
  written += 1; ptr += 1;

  /* Encode u8 last_cell */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->last_cell));
  written += 1; ptr += 1;

  /* Encode struct trn_dleq_pk dleq_pk[first_cell] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->dleq_pk); ++idx) {
      trunnel_assert(written <= avail);
      result = trn_dleq_pk_encode(ptr, avail - written, TRUNNEL_DYNARRAY_GET(&obj->dleq_pk, idx));
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
    }
  }

  /* Encode struct trn_dleq_proof dleq_proof[first_cell] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->dleq_proof); ++idx) {
      trunnel_assert(written <= avail);
      result = trn_dleq_proof_encode(ptr, avail - written, TRUNNEL_DYNARRAY_GET(&obj->dleq_proof, idx));
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
    }
  }

  /* Encode u8 batch_size[first_cell] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->batch_size);
    trunnel_assert(obj->first_cell == elt_len);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->batch_size.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }

  /* Encode struct trn_cell_extension extensions */
  trunnel_assert(written <= avail);
  result = trn_cell_extension_encode(ptr, avail - written, obj->extensions);
  if (result < 0)
    goto fail; /* XXXXXXX !*/
  written += result; ptr += result;

  /* Encode u8 token_num */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->token_num));
  written += 1; ptr += 1;

  /* Encode struct trn_hs_token tokens[token_num] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->tokens); ++idx) {
      trunnel_assert(written <= avail);
      result = trn_hs_token_encode(ptr, avail - written, TRUNNEL_DYNARRAY_GET(&obj->tokens, idx));
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
    }
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As trn_cell_token2_parse(), but do not allocate the output object.
 */
static ssize_t
trn_cell_token2_parse_into(trn_cell_token2_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 first_cell */
  CHECK_REMAINING(1, truncated);
  obj->first_cell = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u8 last_cell */
  CHECK_REMAINING(1, truncated);
  obj->last_cell = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse struct trn_dleq_pk dleq_pk[first_cell] */
  TRUNNEL_DYNARRAY_EXPAND(trn_dleq_pk_t *, &obj->dleq_pk, obj->first_cell, {});
  {
    trn_dleq_pk_t * elt;
    unsigned idx;
    for (idx = 0; idx < obj->first_cell; ++idx) {
      result = trn_dleq_pk_parse(&elt, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      TRUNNEL_DYNARRAY_ADD(trn_dleq_pk_t *, &obj->dleq_pk, elt, {trn_dleq_pk_free(elt);});
    }
  }

  /* Parse struct trn_dleq_proof dleq_proof[first_cell] */
  TRUNNEL_DYNARRAY_EXPAND(trn_dleq_proof_t *, &obj->dleq_proof, obj->first_cell, {});
  {
    trn_dleq_proof_t * elt;
    unsigned idx;
    for (idx = 0; idx < obj->first_cell; ++idx) {
      result = trn_dleq_proof_parse(&elt, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      TRUNNEL_DYNARRAY_ADD(trn_dleq_proof_t *, &obj->dleq_proof, elt, {trn_dleq_proof_free(elt);});
    }
  }

  /* Parse u8 batch_size[first_cell] */
  CHECK_REMAINING(obj->first_cell, truncated);
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->batch_size, obj->first_cell, {});
  obj->batch_size.n_ = obj->first_cell;
  if (obj->first_cell)
    memcpy(obj->batch_size.elts_, ptr, obj->first_cell);
  ptr += obj->first_cell; remaining -= obj->first_cell;

  /* Parse struct trn_cell_extension extensions */
  result = trn_cell_extension_parse(&obj->extensions, ptr, remaining);
  if (result < 0)
    goto relay_fail;
  trunnel_assert((size_t)result <= remaining);
  remaining -= result; ptr += result;

  /* Parse u8 token_num */
  CHECK_REMAINING(1, truncated);
  obj->token_num = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse struct trn_hs_token tokens[token_num] */
  TRUNNEL_DYNARRAY_EXPAND(trn_hs_token_t *, &obj->tokens, obj->token_num, {});
  {
    trn_hs_token_t * elt;
    unsigned idx;
    for (idx = 0; idx < obj->token_num; ++idx) {
      result = trn_hs_token_parse(&elt, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      TRUNNEL_DYNARRAY_ADD(trn_hs_token_t *, &obj->tokens, elt, {trn_hs_token_free(elt);});
    }
  }
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 relay_fail:
  trunnel_assert(result < 0);
  return result;
 trunnel_alloc_failed:
  return -1;
}

ssize_t
trn_cell_token2_parse(trn_cell_token2_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = trn_cell_token2_new();
  if (NULL == *output)
    return -1;
  result = trn_cell_token2_parse_into(*output, input, len_in);
  if (result < 0) {
    trn_cell_token2_free(*output);
    *output = NULL;
  }
  return result;
}
