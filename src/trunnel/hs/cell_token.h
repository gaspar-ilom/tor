/* cell_token.h -- generated by Trunnel v1.5.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_CELL_TOKEN_H
#define TRUNNEL_CELL_TOKEN_H

#include <stdint.h>
#include "trunnel.h"

struct trn_cell_extension_st;
#define TRUNNEL_HS_TOKEN_LEN 64
#define TRUNNEL_HS_DLEQ_PK_LEN 64
#define TRUNNEL_HS_DLEQ_PROOF_LEN 64
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_DLEQ_PK)
struct trn_dleq_pk_st {
  uint8_t dleq_pk[TRUNNEL_HS_DLEQ_PK_LEN];
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_dleq_pk_st trn_dleq_pk_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_DLEQ_PROOF)
struct trn_dleq_proof_st {
  uint8_t dleq_proof[TRUNNEL_HS_DLEQ_PROOF_LEN];
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_dleq_proof_st trn_dleq_proof_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_HS_POW)
struct trn_hs_pow_st {
  uint8_t pow_len;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) proof_of_work;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_hs_pow_st trn_hs_pow_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_HS_TOKEN)
struct trn_hs_token_st {
  uint8_t seq_num;
  uint8_t token[TRUNNEL_HS_TOKEN_LEN];
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_hs_token_st trn_hs_token_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_CELL_TOKEN1)
struct trn_cell_token1_st {
  uint8_t first_cell;
  uint8_t last_cell;
  TRUNNEL_DYNARRAY_HEAD(, struct trn_hs_pow_st *) pow;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) batch_size;
  struct trn_cell_extension_st *extensions;
  uint8_t token_num;
  TRUNNEL_DYNARRAY_HEAD(, struct trn_hs_token_st *) tokens;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_cell_token1_st trn_cell_token1_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_CELL_TOKEN2)
struct trn_cell_token2_st {
  uint8_t first_cell;
  uint8_t last_cell;
  TRUNNEL_DYNARRAY_HEAD(, struct trn_dleq_pk_st *) dleq_pk;
  TRUNNEL_DYNARRAY_HEAD(, struct trn_dleq_proof_st *) dleq_proof;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) batch_size;
  struct trn_cell_extension_st *extensions;
  uint8_t token_num;
  TRUNNEL_DYNARRAY_HEAD(, struct trn_hs_token_st *) tokens;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_cell_token2_st trn_cell_token2_t;
/** Return a newly allocated trn_dleq_pk with all elements set to
 * zero.
 */
trn_dleq_pk_t *trn_dleq_pk_new(void);
/** Release all storage held by the trn_dleq_pk in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void trn_dleq_pk_free(trn_dleq_pk_t *victim);
/** Try to parse a trn_dleq_pk from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * trn_dleq_pk_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t trn_dleq_pk_parse(trn_dleq_pk_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_dleq_pk in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t trn_dleq_pk_encoded_len(const trn_dleq_pk_t *obj);
/** Try to encode the trn_dleq_pk from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_dleq_pk_encode(uint8_t *output, size_t avail, const trn_dleq_pk_t *input);
/** Check whether the internal state of the trn_dleq_pk in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *trn_dleq_pk_check(const trn_dleq_pk_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_dleq_pk_clear_errors(trn_dleq_pk_t *obj);
/** Return the (constant) length of the array holding the dleq_pk
 * field of the trn_dleq_pk_t in 'inp'.
 */
size_t trn_dleq_pk_getlen_dleq_pk(const trn_dleq_pk_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * dleq_pk of the trn_dleq_pk_t in 'inp'.
 */
uint8_t trn_dleq_pk_get_dleq_pk(trn_dleq_pk_t *inp, size_t idx);
/** As trn_dleq_pk_get_dleq_pk, but take and return a const pointer
 */
uint8_t trn_dleq_pk_getconst_dleq_pk(const trn_dleq_pk_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * dleq_pk of the trn_dleq_pk_t in 'inp', so that it will hold the
 * value 'elt'.
 */
int trn_dleq_pk_set_dleq_pk(trn_dleq_pk_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the TRUNNEL_HS_DLEQ_PK_LEN-element array field
 * dleq_pk of 'inp'.
 */
uint8_t * trn_dleq_pk_getarray_dleq_pk(trn_dleq_pk_t *inp);
/** As trn_dleq_pk_get_dleq_pk, but take and return a const pointer
 */
const uint8_t  * trn_dleq_pk_getconstarray_dleq_pk(const trn_dleq_pk_t *inp);
/** Return a newly allocated trn_dleq_proof with all elements set to
 * zero.
 */
trn_dleq_proof_t *trn_dleq_proof_new(void);
/** Release all storage held by the trn_dleq_proof in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void trn_dleq_proof_free(trn_dleq_proof_t *victim);
/** Try to parse a trn_dleq_proof from the buffer in 'input', using up
 * to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * trn_dleq_proof_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t trn_dleq_proof_parse(trn_dleq_proof_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_dleq_proof in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t trn_dleq_proof_encoded_len(const trn_dleq_proof_t *obj);
/** Try to encode the trn_dleq_proof from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_dleq_proof_encode(uint8_t *output, size_t avail, const trn_dleq_proof_t *input);
/** Check whether the internal state of the trn_dleq_proof in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *trn_dleq_proof_check(const trn_dleq_proof_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_dleq_proof_clear_errors(trn_dleq_proof_t *obj);
/** Return the (constant) length of the array holding the dleq_proof
 * field of the trn_dleq_proof_t in 'inp'.
 */
size_t trn_dleq_proof_getlen_dleq_proof(const trn_dleq_proof_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * dleq_proof of the trn_dleq_proof_t in 'inp'.
 */
uint8_t trn_dleq_proof_get_dleq_proof(trn_dleq_proof_t *inp, size_t idx);
/** As trn_dleq_proof_get_dleq_proof, but take and return a const
 * pointer
 */
uint8_t trn_dleq_proof_getconst_dleq_proof(const trn_dleq_proof_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * dleq_proof of the trn_dleq_proof_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int trn_dleq_proof_set_dleq_proof(trn_dleq_proof_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the TRUNNEL_HS_DLEQ_PROOF_LEN-element array
 * field dleq_proof of 'inp'.
 */
uint8_t * trn_dleq_proof_getarray_dleq_proof(trn_dleq_proof_t *inp);
/** As trn_dleq_proof_get_dleq_proof, but take and return a const
 * pointer
 */
const uint8_t  * trn_dleq_proof_getconstarray_dleq_proof(const trn_dleq_proof_t *inp);
/** Return a newly allocated trn_hs_pow with all elements set to zero.
 */
trn_hs_pow_t *trn_hs_pow_new(void);
/** Release all storage held by the trn_hs_pow in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void trn_hs_pow_free(trn_hs_pow_t *victim);
/** Try to parse a trn_hs_pow from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * trn_hs_pow_t. On failure, return -2 if the input appears truncated,
 * and -1 if the input is otherwise invalid.
 */
ssize_t trn_hs_pow_parse(trn_hs_pow_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_hs_pow in 'obj'. On failure, return a negative value. Note that
 * this value may be an overestimate, and can even be an underestimate
 * for certain unencodeable objects.
 */
ssize_t trn_hs_pow_encoded_len(const trn_hs_pow_t *obj);
/** Try to encode the trn_hs_pow from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_hs_pow_encode(uint8_t *output, size_t avail, const trn_hs_pow_t *input);
/** Check whether the internal state of the trn_hs_pow in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *trn_hs_pow_check(const trn_hs_pow_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_hs_pow_clear_errors(trn_hs_pow_t *obj);
/** Return the value of the pow_len field of the trn_hs_pow_t in 'inp'
 */
uint8_t trn_hs_pow_get_pow_len(const trn_hs_pow_t *inp);
/** Set the value of the pow_len field of the trn_hs_pow_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int trn_hs_pow_set_pow_len(trn_hs_pow_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the proof_of_work
 * field of the trn_hs_pow_t in 'inp'.
 */
size_t trn_hs_pow_getlen_proof_of_work(const trn_hs_pow_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * proof_of_work of the trn_hs_pow_t in 'inp'.
 */
uint8_t trn_hs_pow_get_proof_of_work(trn_hs_pow_t *inp, size_t idx);
/** As trn_hs_pow_get_proof_of_work, but take and return a const
 * pointer
 */
uint8_t trn_hs_pow_getconst_proof_of_work(const trn_hs_pow_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * proof_of_work of the trn_hs_pow_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int trn_hs_pow_set_proof_of_work(trn_hs_pow_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field
 * proof_of_work of the trn_hs_pow_t in 'inp'.
 */
int trn_hs_pow_add_proof_of_work(trn_hs_pow_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field proof_of_work
 * of 'inp'.
 */
uint8_t * trn_hs_pow_getarray_proof_of_work(trn_hs_pow_t *inp);
/** As trn_hs_pow_get_proof_of_work, but take and return a const
 * pointer
 */
const uint8_t  * trn_hs_pow_getconstarray_proof_of_work(const trn_hs_pow_t *inp);
/** Change the length of the variable-length array field proof_of_work
 * of 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on
 * success; return -1 and set the error code on 'inp' on failure.
 */
int trn_hs_pow_setlen_proof_of_work(trn_hs_pow_t *inp, size_t newlen);
/** Return a newly allocated trn_hs_token with all elements set to
 * zero.
 */
trn_hs_token_t *trn_hs_token_new(void);
/** Release all storage held by the trn_hs_token in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void trn_hs_token_free(trn_hs_token_t *victim);
/** Try to parse a trn_hs_token from the buffer in 'input', using up
 * to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * trn_hs_token_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t trn_hs_token_parse(trn_hs_token_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_hs_token in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t trn_hs_token_encoded_len(const trn_hs_token_t *obj);
/** Try to encode the trn_hs_token from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_hs_token_encode(uint8_t *output, size_t avail, const trn_hs_token_t *input);
/** Check whether the internal state of the trn_hs_token in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *trn_hs_token_check(const trn_hs_token_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_hs_token_clear_errors(trn_hs_token_t *obj);
/** Return the value of the seq_num field of the trn_hs_token_t in
 * 'inp'
 */
uint8_t trn_hs_token_get_seq_num(const trn_hs_token_t *inp);
/** Set the value of the seq_num field of the trn_hs_token_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int trn_hs_token_set_seq_num(trn_hs_token_t *inp, uint8_t val);
/** Return the (constant) length of the array holding the token field
 * of the trn_hs_token_t in 'inp'.
 */
size_t trn_hs_token_getlen_token(const trn_hs_token_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * token of the trn_hs_token_t in 'inp'.
 */
uint8_t trn_hs_token_get_token(trn_hs_token_t *inp, size_t idx);
/** As trn_hs_token_get_token, but take and return a const pointer
 */
uint8_t trn_hs_token_getconst_token(const trn_hs_token_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * token of the trn_hs_token_t in 'inp', so that it will hold the
 * value 'elt'.
 */
int trn_hs_token_set_token(trn_hs_token_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the TRUNNEL_HS_TOKEN_LEN-element array field
 * token of 'inp'.
 */
uint8_t * trn_hs_token_getarray_token(trn_hs_token_t *inp);
/** As trn_hs_token_get_token, but take and return a const pointer
 */
const uint8_t  * trn_hs_token_getconstarray_token(const trn_hs_token_t *inp);
/** Return a newly allocated trn_cell_token1 with all elements set to
 * zero.
 */
trn_cell_token1_t *trn_cell_token1_new(void);
/** Release all storage held by the trn_cell_token1 in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void trn_cell_token1_free(trn_cell_token1_t *victim);
/** Try to parse a trn_cell_token1 from the buffer in 'input', using
 * up to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * trn_cell_token1_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t trn_cell_token1_parse(trn_cell_token1_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_cell_token1 in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t trn_cell_token1_encoded_len(const trn_cell_token1_t *obj);
/** Try to encode the trn_cell_token1 from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_cell_token1_encode(uint8_t *output, size_t avail, const trn_cell_token1_t *input);
/** Check whether the internal state of the trn_cell_token1 in 'obj'
 * is consistent. Return NULL if it is, and a short message if it is
 * not.
 */
const char *trn_cell_token1_check(const trn_cell_token1_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_cell_token1_clear_errors(trn_cell_token1_t *obj);
/** Return the value of the first_cell field of the trn_cell_token1_t
 * in 'inp'
 */
uint8_t trn_cell_token1_get_first_cell(const trn_cell_token1_t *inp);
/** Set the value of the first_cell field of the trn_cell_token1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int trn_cell_token1_set_first_cell(trn_cell_token1_t *inp, uint8_t val);
/** Return the value of the last_cell field of the trn_cell_token1_t
 * in 'inp'
 */
uint8_t trn_cell_token1_get_last_cell(const trn_cell_token1_t *inp);
/** Set the value of the last_cell field of the trn_cell_token1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int trn_cell_token1_set_last_cell(trn_cell_token1_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the pow field of
 * the trn_cell_token1_t in 'inp'.
 */
size_t trn_cell_token1_getlen_pow(const trn_cell_token1_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * pow of the trn_cell_token1_t in 'inp'.
 */
struct trn_hs_pow_st * trn_cell_token1_get_pow(trn_cell_token1_t *inp, size_t idx);
/** As trn_cell_token1_get_pow, but take and return a const pointer
 */
 const struct trn_hs_pow_st * trn_cell_token1_getconst_pow(const trn_cell_token1_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * pow of the trn_cell_token1_t in 'inp', so that it will hold the
 * value 'elt'. Free the previous value, if any.
 */
int trn_cell_token1_set_pow(trn_cell_token1_t *inp, size_t idx, struct trn_hs_pow_st * elt);
/** As trn_cell_token1_set_pow, but does not free the previous value.
 */
int trn_cell_token1_set0_pow(trn_cell_token1_t *inp, size_t idx, struct trn_hs_pow_st * elt);
/** Append a new element 'elt' to the dynamic array field pow of the
 * trn_cell_token1_t in 'inp'.
 */
int trn_cell_token1_add_pow(trn_cell_token1_t *inp, struct trn_hs_pow_st * elt);
/** Return a pointer to the variable-length array field pow of 'inp'.
 */
struct trn_hs_pow_st * * trn_cell_token1_getarray_pow(trn_cell_token1_t *inp);
/** As trn_cell_token1_get_pow, but take and return a const pointer
 */
const struct trn_hs_pow_st *  const  * trn_cell_token1_getconstarray_pow(const trn_cell_token1_t *inp);
/** Change the length of the variable-length array field pow of 'inp'
 * to 'newlen'.Fill extra elements with NULL; free removed elements.
 * Return 0 on success; return -1 and set the error code on 'inp' on
 * failure.
 */
int trn_cell_token1_setlen_pow(trn_cell_token1_t *inp, size_t newlen);
/** Return the length of the dynamic array holding the batch_size
 * field of the trn_cell_token1_t in 'inp'.
 */
size_t trn_cell_token1_getlen_batch_size(const trn_cell_token1_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * batch_size of the trn_cell_token1_t in 'inp'.
 */
uint8_t trn_cell_token1_get_batch_size(trn_cell_token1_t *inp, size_t idx);
/** As trn_cell_token1_get_batch_size, but take and return a const
 * pointer
 */
uint8_t trn_cell_token1_getconst_batch_size(const trn_cell_token1_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * batch_size of the trn_cell_token1_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int trn_cell_token1_set_batch_size(trn_cell_token1_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field batch_size
 * of the trn_cell_token1_t in 'inp'.
 */
int trn_cell_token1_add_batch_size(trn_cell_token1_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field batch_size of
 * 'inp'.
 */
uint8_t * trn_cell_token1_getarray_batch_size(trn_cell_token1_t *inp);
/** As trn_cell_token1_get_batch_size, but take and return a const
 * pointer
 */
const uint8_t  * trn_cell_token1_getconstarray_batch_size(const trn_cell_token1_t *inp);
/** Change the length of the variable-length array field batch_size of
 * 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int trn_cell_token1_setlen_batch_size(trn_cell_token1_t *inp, size_t newlen);
/** Return the value of the extensions field of the trn_cell_token1_t
 * in 'inp'
 */
struct trn_cell_extension_st * trn_cell_token1_get_extensions(trn_cell_token1_t *inp);
/** As trn_cell_token1_get_extensions, but take and return a const
 * pointer
 */
const struct trn_cell_extension_st * trn_cell_token1_getconst_extensions(const trn_cell_token1_t *inp);
/** Set the value of the extensions field of the trn_cell_token1_t in
 * 'inp' to 'val'. Free the old value if any. Steals the referenceto
 * 'val'.Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int trn_cell_token1_set_extensions(trn_cell_token1_t *inp, struct trn_cell_extension_st *val);
/** As trn_cell_token1_set_extensions, but does not free the previous
 * value.
 */
int trn_cell_token1_set0_extensions(trn_cell_token1_t *inp, struct trn_cell_extension_st *val);
/** Return the value of the token_num field of the trn_cell_token1_t
 * in 'inp'
 */
uint8_t trn_cell_token1_get_token_num(const trn_cell_token1_t *inp);
/** Set the value of the token_num field of the trn_cell_token1_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int trn_cell_token1_set_token_num(trn_cell_token1_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the tokens field of
 * the trn_cell_token1_t in 'inp'.
 */
size_t trn_cell_token1_getlen_tokens(const trn_cell_token1_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * tokens of the trn_cell_token1_t in 'inp'.
 */
struct trn_hs_token_st * trn_cell_token1_get_tokens(trn_cell_token1_t *inp, size_t idx);
/** As trn_cell_token1_get_tokens, but take and return a const pointer
 */
 const struct trn_hs_token_st * trn_cell_token1_getconst_tokens(const trn_cell_token1_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * tokens of the trn_cell_token1_t in 'inp', so that it will hold the
 * value 'elt'. Free the previous value, if any.
 */
int trn_cell_token1_set_tokens(trn_cell_token1_t *inp, size_t idx, struct trn_hs_token_st * elt);
/** As trn_cell_token1_set_tokens, but does not free the previous
 * value.
 */
int trn_cell_token1_set0_tokens(trn_cell_token1_t *inp, size_t idx, struct trn_hs_token_st * elt);
/** Append a new element 'elt' to the dynamic array field tokens of
 * the trn_cell_token1_t in 'inp'.
 */
int trn_cell_token1_add_tokens(trn_cell_token1_t *inp, struct trn_hs_token_st * elt);
/** Return a pointer to the variable-length array field tokens of
 * 'inp'.
 */
struct trn_hs_token_st * * trn_cell_token1_getarray_tokens(trn_cell_token1_t *inp);
/** As trn_cell_token1_get_tokens, but take and return a const pointer
 */
const struct trn_hs_token_st *  const  * trn_cell_token1_getconstarray_tokens(const trn_cell_token1_t *inp);
/** Change the length of the variable-length array field tokens of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int trn_cell_token1_setlen_tokens(trn_cell_token1_t *inp, size_t newlen);
/** Return a newly allocated trn_cell_token2 with all elements set to
 * zero.
 */
trn_cell_token2_t *trn_cell_token2_new(void);
/** Release all storage held by the trn_cell_token2 in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void trn_cell_token2_free(trn_cell_token2_t *victim);
/** Try to parse a trn_cell_token2 from the buffer in 'input', using
 * up to 'len_in' bytes from the input buffer. On success, return the
 * number of bytes consumed and set *output to the newly allocated
 * trn_cell_token2_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t trn_cell_token2_parse(trn_cell_token2_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_cell_token2 in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t trn_cell_token2_encoded_len(const trn_cell_token2_t *obj);
/** Try to encode the trn_cell_token2 from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_cell_token2_encode(uint8_t *output, size_t avail, const trn_cell_token2_t *input);
/** Check whether the internal state of the trn_cell_token2 in 'obj'
 * is consistent. Return NULL if it is, and a short message if it is
 * not.
 */
const char *trn_cell_token2_check(const trn_cell_token2_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_cell_token2_clear_errors(trn_cell_token2_t *obj);
/** Return the value of the first_cell field of the trn_cell_token2_t
 * in 'inp'
 */
uint8_t trn_cell_token2_get_first_cell(const trn_cell_token2_t *inp);
/** Set the value of the first_cell field of the trn_cell_token2_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int trn_cell_token2_set_first_cell(trn_cell_token2_t *inp, uint8_t val);
/** Return the value of the last_cell field of the trn_cell_token2_t
 * in 'inp'
 */
uint8_t trn_cell_token2_get_last_cell(const trn_cell_token2_t *inp);
/** Set the value of the last_cell field of the trn_cell_token2_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int trn_cell_token2_set_last_cell(trn_cell_token2_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the dleq_pk field
 * of the trn_cell_token2_t in 'inp'.
 */
size_t trn_cell_token2_getlen_dleq_pk(const trn_cell_token2_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * dleq_pk of the trn_cell_token2_t in 'inp'.
 */
struct trn_dleq_pk_st * trn_cell_token2_get_dleq_pk(trn_cell_token2_t *inp, size_t idx);
/** As trn_cell_token2_get_dleq_pk, but take and return a const
 * pointer
 */
 const struct trn_dleq_pk_st * trn_cell_token2_getconst_dleq_pk(const trn_cell_token2_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * dleq_pk of the trn_cell_token2_t in 'inp', so that it will hold the
 * value 'elt'. Free the previous value, if any.
 */
int trn_cell_token2_set_dleq_pk(trn_cell_token2_t *inp, size_t idx, struct trn_dleq_pk_st * elt);
/** As trn_cell_token2_set_dleq_pk, but does not free the previous
 * value.
 */
int trn_cell_token2_set0_dleq_pk(trn_cell_token2_t *inp, size_t idx, struct trn_dleq_pk_st * elt);
/** Append a new element 'elt' to the dynamic array field dleq_pk of
 * the trn_cell_token2_t in 'inp'.
 */
int trn_cell_token2_add_dleq_pk(trn_cell_token2_t *inp, struct trn_dleq_pk_st * elt);
/** Return a pointer to the variable-length array field dleq_pk of
 * 'inp'.
 */
struct trn_dleq_pk_st * * trn_cell_token2_getarray_dleq_pk(trn_cell_token2_t *inp);
/** As trn_cell_token2_get_dleq_pk, but take and return a const
 * pointer
 */
const struct trn_dleq_pk_st *  const  * trn_cell_token2_getconstarray_dleq_pk(const trn_cell_token2_t *inp);
/** Change the length of the variable-length array field dleq_pk of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int trn_cell_token2_setlen_dleq_pk(trn_cell_token2_t *inp, size_t newlen);
/** Return the length of the dynamic array holding the dleq_proof
 * field of the trn_cell_token2_t in 'inp'.
 */
size_t trn_cell_token2_getlen_dleq_proof(const trn_cell_token2_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * dleq_proof of the trn_cell_token2_t in 'inp'.
 */
struct trn_dleq_proof_st * trn_cell_token2_get_dleq_proof(trn_cell_token2_t *inp, size_t idx);
/** As trn_cell_token2_get_dleq_proof, but take and return a const
 * pointer
 */
 const struct trn_dleq_proof_st * trn_cell_token2_getconst_dleq_proof(const trn_cell_token2_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * dleq_proof of the trn_cell_token2_t in 'inp', so that it will hold
 * the value 'elt'. Free the previous value, if any.
 */
int trn_cell_token2_set_dleq_proof(trn_cell_token2_t *inp, size_t idx, struct trn_dleq_proof_st * elt);
/** As trn_cell_token2_set_dleq_proof, but does not free the previous
 * value.
 */
int trn_cell_token2_set0_dleq_proof(trn_cell_token2_t *inp, size_t idx, struct trn_dleq_proof_st * elt);
/** Append a new element 'elt' to the dynamic array field dleq_proof
 * of the trn_cell_token2_t in 'inp'.
 */
int trn_cell_token2_add_dleq_proof(trn_cell_token2_t *inp, struct trn_dleq_proof_st * elt);
/** Return a pointer to the variable-length array field dleq_proof of
 * 'inp'.
 */
struct trn_dleq_proof_st * * trn_cell_token2_getarray_dleq_proof(trn_cell_token2_t *inp);
/** As trn_cell_token2_get_dleq_proof, but take and return a const
 * pointer
 */
const struct trn_dleq_proof_st *  const  * trn_cell_token2_getconstarray_dleq_proof(const trn_cell_token2_t *inp);
/** Change the length of the variable-length array field dleq_proof of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int trn_cell_token2_setlen_dleq_proof(trn_cell_token2_t *inp, size_t newlen);
/** Return the length of the dynamic array holding the batch_size
 * field of the trn_cell_token2_t in 'inp'.
 */
size_t trn_cell_token2_getlen_batch_size(const trn_cell_token2_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * batch_size of the trn_cell_token2_t in 'inp'.
 */
uint8_t trn_cell_token2_get_batch_size(trn_cell_token2_t *inp, size_t idx);
/** As trn_cell_token2_get_batch_size, but take and return a const
 * pointer
 */
uint8_t trn_cell_token2_getconst_batch_size(const trn_cell_token2_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * batch_size of the trn_cell_token2_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int trn_cell_token2_set_batch_size(trn_cell_token2_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field batch_size
 * of the trn_cell_token2_t in 'inp'.
 */
int trn_cell_token2_add_batch_size(trn_cell_token2_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field batch_size of
 * 'inp'.
 */
uint8_t * trn_cell_token2_getarray_batch_size(trn_cell_token2_t *inp);
/** As trn_cell_token2_get_batch_size, but take and return a const
 * pointer
 */
const uint8_t  * trn_cell_token2_getconstarray_batch_size(const trn_cell_token2_t *inp);
/** Change the length of the variable-length array field batch_size of
 * 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int trn_cell_token2_setlen_batch_size(trn_cell_token2_t *inp, size_t newlen);
/** Return the value of the extensions field of the trn_cell_token2_t
 * in 'inp'
 */
struct trn_cell_extension_st * trn_cell_token2_get_extensions(trn_cell_token2_t *inp);
/** As trn_cell_token2_get_extensions, but take and return a const
 * pointer
 */
const struct trn_cell_extension_st * trn_cell_token2_getconst_extensions(const trn_cell_token2_t *inp);
/** Set the value of the extensions field of the trn_cell_token2_t in
 * 'inp' to 'val'. Free the old value if any. Steals the referenceto
 * 'val'.Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int trn_cell_token2_set_extensions(trn_cell_token2_t *inp, struct trn_cell_extension_st *val);
/** As trn_cell_token2_set_extensions, but does not free the previous
 * value.
 */
int trn_cell_token2_set0_extensions(trn_cell_token2_t *inp, struct trn_cell_extension_st *val);
/** Return the value of the token_num field of the trn_cell_token2_t
 * in 'inp'
 */
uint8_t trn_cell_token2_get_token_num(const trn_cell_token2_t *inp);
/** Set the value of the token_num field of the trn_cell_token2_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int trn_cell_token2_set_token_num(trn_cell_token2_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the tokens field of
 * the trn_cell_token2_t in 'inp'.
 */
size_t trn_cell_token2_getlen_tokens(const trn_cell_token2_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * tokens of the trn_cell_token2_t in 'inp'.
 */
struct trn_hs_token_st * trn_cell_token2_get_tokens(trn_cell_token2_t *inp, size_t idx);
/** As trn_cell_token2_get_tokens, but take and return a const pointer
 */
 const struct trn_hs_token_st * trn_cell_token2_getconst_tokens(const trn_cell_token2_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * tokens of the trn_cell_token2_t in 'inp', so that it will hold the
 * value 'elt'. Free the previous value, if any.
 */
int trn_cell_token2_set_tokens(trn_cell_token2_t *inp, size_t idx, struct trn_hs_token_st * elt);
/** As trn_cell_token2_set_tokens, but does not free the previous
 * value.
 */
int trn_cell_token2_set0_tokens(trn_cell_token2_t *inp, size_t idx, struct trn_hs_token_st * elt);
/** Append a new element 'elt' to the dynamic array field tokens of
 * the trn_cell_token2_t in 'inp'.
 */
int trn_cell_token2_add_tokens(trn_cell_token2_t *inp, struct trn_hs_token_st * elt);
/** Return a pointer to the variable-length array field tokens of
 * 'inp'.
 */
struct trn_hs_token_st * * trn_cell_token2_getarray_tokens(trn_cell_token2_t *inp);
/** As trn_cell_token2_get_tokens, but take and return a const pointer
 */
const struct trn_hs_token_st *  const  * trn_cell_token2_getconstarray_tokens(const trn_cell_token2_t *inp);
/** Change the length of the variable-length array field tokens of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int trn_cell_token2_setlen_tokens(trn_cell_token2_t *inp, size_t newlen);


#endif
